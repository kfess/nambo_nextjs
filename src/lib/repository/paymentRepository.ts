import { PrismaClient, Payment as PrismaPayment } from "@prisma/client";
import { Payment } from "@/lib/domain/payment";
import { PaymentType } from "@/lib/domain/paymentSchema";

export interface IPaymentRepository {
  createPayment: (paymentData: Payment) => Promise<PaymentType>;
  getPayment: (paymentId: string) => Promise<PaymentType | null>;
  getPayments: (eventId: string) => Promise<PaymentType[]>;
  updatePayment: (
    paymentId: string,
    paymentData: Payment
  ) => Promise<PaymentType>;
  deletePayment: (paymentId: string) => Promise<PaymentType>;
}

export class PaymentRepository implements IPaymentRepository {
  constructor(private prisma: PrismaClient) {}

  async createPayment(paymentData: Payment): Promise<PaymentType> {
    // paymentId is automatically generated by Prisma.
    // So, we don't need to pass it to the Prisma.
    const prismPayment = await this.prisma.payment.create({
      data: {
        eventId: paymentData.eventId,
        purpose: paymentData.purpose,
        payer: paymentData.payer,
        payees: {
          create: paymentData.payees.map((payee) => ({ name: payee })),
        },
        cost: paymentData.cost,
      },
      include: { payees: true },
    });

    return this.toDomain(prismPayment);
  }

  async getPayment(paymentId: string): Promise<PaymentType | null> {
    const prismaPayment = await this.prisma.payment.findUnique({
      where: { paymentId },
      include: { payees: true },
    });

    if (!prismaPayment) return null;
    return this.toDomain(prismaPayment);
  }

  async getPayments(eventId: string): Promise<PaymentType[]> {
    const prismaPayments = await this.prisma.payment.findMany({
      where: { eventId },
      include: { payees: true },
    });

    return prismaPayments.map((prismaPayment) => this.toDomain(prismaPayment));
  }

  async updatePayment(
    paymentId: string,
    paymentData: Payment
  ): Promise<PaymentType> {
    const prismaPayment = await this.prisma.payment.update({
      where: { paymentId },
      data: {
        eventId: paymentData.eventId,
        purpose: paymentData.purpose,
        payer: paymentData.payer,
        payees: {
          create: paymentData.payees.map((payee) => ({ name: payee })),
        },
        cost: paymentData.cost,
      },
      include: { payees: true },
    });

    return this.toDomain(prismaPayment);
  }

  async deletePayment(paymentId: string): Promise<PaymentType> {
    const prismaPayment = await this.prisma.payment.delete({
      where: { paymentId },
      include: { payees: true },
    });

    return this.toDomain(prismaPayment);
  }

  // Prisma の Payment を Domain の Payment に変換するためのメソッド
  toDomain(
    prismaPayment: PrismaPayment & { payees: { name: string }[] }
  ): Payment {
    return new Payment({
      paymentId: prismaPayment.paymentId,
      eventId: prismaPayment.eventId,
      purpose: prismaPayment.purpose,
      payer: prismaPayment.payer,
      payees: prismaPayment.payees.map((payee) => payee.name),
      cost: prismaPayment.cost,
    });
  }
}
