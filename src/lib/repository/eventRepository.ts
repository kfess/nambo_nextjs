import { PrismaClient, Event as PrismaEvent } from "@prisma/client";
import { Event } from "@/lib/domain/event";
import { EventType } from "@/lib/domain/eventSchema";
import { MoneyUnit, Member } from "@/lib/domain/eventSchema";

export interface IEventRepository {
  createEvent: (eventData: Event) => Promise<EventType>;
  getEvent: (eventId: string) => Promise<EventType | null>;
  updateEvent: (id: string, eventData: EventType) => Promise<EventType>;
}

export class EventRepository implements IEventRepository {
  constructor(private prisma: PrismaClient) {}

  async createEvent(eventData: Event): Promise<EventType> {
    // eventId is automatically generated by Prisma.
    // So, we don't need to pass it to the Prisma.
    const prismaEvent = await this.prisma.event.create({
      data: {
        eventName: eventData.eventName,
        memo: eventData.memo,
        fromDate: eventData.fromDate,
        toDate: eventData.toDate,
        moneyUnit: eventData.moneyUnit,
        members: {
          create: eventData.members,
        },
      },
      include: { members: true },
    });

    return this.toDomain(prismaEvent);
  }

  async getEvent(eventId: string): Promise<EventType | null> {
    const prismaEvent = await this.prisma.event.findUnique({
      where: { eventId },
      include: { members: true },
    });

    if (!prismaEvent) return null;
    return this.toDomain(prismaEvent);
  }

  async updateEvent(eventId: string, eventData: EventType): Promise<EventType> {
    return await this.prisma.$transaction(async (prisma) => {
      const currentMembers = await prisma.member.findMany({
        where: { eventId },
      });

      const updatedMemberIds = new Set(
        eventData.members.map((m) => m.memberId)
      );
      const membersToDelete = currentMembers.filter(
        (m) => !updatedMemberIds.has(m.memberId)
      ); // 削除するメンバーの特定

      // 更新するメンバーと新規メンバーの特定
      const membersToUpdate = [];
      const membersToAdd = [];

      for (const member of eventData.members) {
        const existingMember = currentMembers.find(
          (m) => m.memberId === member.memberId
        );
        if (existingMember) {
          membersToUpdate.push({ ...member, id: existingMember.id });
        } else {
          membersToAdd.push(member);
        }
      }

      // メンバーの削除
      await Promise.all(
        membersToDelete.map((m) =>
          prisma.member.delete({ where: { id: m.id } })
        )
      );

      // メンバーの更新
      await Promise.all(
        membersToUpdate.map((m) =>
          prisma.member.update({ where: { id: m.id }, data: m })
        )
      );

      // メンバーの追加
      await Promise.all(
        membersToAdd.map((m) =>
          prisma.member.create({ data: { ...m, eventId } })
        )
      );

      // イベントの更新
      const prismaEvent = await prisma.event.update({
        where: { eventId },
        data: {
          eventName: eventData.eventName,
          memo: eventData.memo,
          fromDate: eventData.fromDate,
          toDate: eventData.toDate,
          moneyUnit: eventData.moneyUnit,
        },
        include: { members: true },
      });

      return this.toDomain(prismaEvent);
    });
  }

  // Prisma の Event を Domain の Event に変換するためのメソッド
  toDomain(prismaEvent: PrismaEvent & { members: Member[] }): EventType {
    return new Event({
      eventId: prismaEvent.eventId,
      eventName: prismaEvent.eventName,
      memo: prismaEvent.memo,
      fromDate: prismaEvent.fromDate.toISOString(),
      toDate: prismaEvent.toDate.toISOString(),
      members: prismaEvent.members,
      moneyUnit: prismaEvent.moneyUnit as MoneyUnit,
    });
  }
}
